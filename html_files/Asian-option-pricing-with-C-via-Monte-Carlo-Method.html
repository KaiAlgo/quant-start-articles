
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="wl3-8ed1QZjI0iYZMv10zoZWYElkMObTfwLlWIj9cpA" />
    <meta name="description" content="Asian option pricing with C++ via Monte Carlo Methods">

    <link rel="icon" href="/static/images/favicon.png">

    <title>Asian option pricing with C++ via Monte Carlo Methods | QuantStart</title>
    
    
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,900&display=swap" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900&display=swap" rel="stylesheet"> 
<link href="/static/css/bootstrap.min.css" rel="stylesheet">
<link href="/static/css/prism.css" rel="stylesheet">
<link href="/static/css/qs.css?v=10" rel="stylesheet">
    
  </head>

  <body>
    <header class="header covered-header" style="background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url(https://quantstartmedia.s3.amazonaws.com/images/article-images/article-backgrounds/cpp.jpg);">
  
<nav class="nav">
  <div class="container nav-container">
    <div class="nav-row row d-flex justify-content-between align-items-center">
      <div class="col-2">
        <ul class="nav-items justify-content-end small-capitals align-items-center">
          <li class="nav-item">
            <a class="link-fade" href="/">QuantStart</a>
          </li>
        </ul>
      </div>
      <div class="col-auto col-logo">
        <ul id="top-nav-menu" class="nav-items justify-content-end align-items-center">
          
          <li class="nav-item">
            <a class="link-fade" href="/qsalpha/">QSAlpha</a>
          </li>
          
          
          <li class="nav-item">
            <a class="link-fade" href="/quantcademy/">Quantcademy</a>
          </li>
          
          <li id="menu-link-ebooks" class="nav-item">
            <a class="link-fade" href="#">Books</a>
            <div id="menu-pane-ebooks" class="nav-items menu-dropdown-pane">
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
              </div>
            </div>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/qstrader/">QSTrader</a>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/articles/">Articles</a>
          </li>
          
          <li class="nav-item">
            <a class="link-fade" href="/members/login/">Login</a>
          </li>
          
        </ul>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
    </div>
  </div>
</nav>

<nav id="mobile-nav" class="mobile-nav text-left">
  <div class="container">
    <ul class="mt-4 ml-3 mobile-nav-menu">
      <li class="nav-item">
        <a class="link-fade d-block" href="/">QuantStart</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qsalpha/">QSAlpha</a>
      </li>
      

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/quantcademy/">Quantcademy</a>
      </li>
      

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="#">Books</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qstrader/">QSTrader</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/articles/">Articles</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/members/login/">Login</a>
      </li>
      
    </ul>
    <button class="nav-toggle mobile-nav-close">
      <svg id="mobile-nav-close-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19.77,5.63,13.41,12l6.36,6.37a1,1,0,0,1-1.41,1.41L12,13.41,5.63,19.77a1,1,0,0,1-1.44-1.39l0,0L10.58,12,4.21,5.63a1,1,0,0,1,0-1.42,1,1,0,0,1,1.41,0l0,0L12,10.58l6.37-6.37a1,1,0,0,1,1.41,0A1,1,0,0,1,19.77,5.63Z"></path>
      </svg>
    </button>
  </div>
</nav>

  <div class="container hero-container">
    <section class="mt-5 mb-4">
      <div class="row justify-content-center">
        <div class="col-12 text-center">
          <p class="hero">Asian option pricing with C++ via Monte Carlo Methods</p>
          <p class="hero subhero">Asian option pricing with C++ via Monte Carlo Methods</p>
        </div>
      </div>
    </section>
  </div>
</header>
    
<section class="container content-container">
  <div class="row">
    <div class="col-md-8 order-md-2">
      <section class="content article-content">
        
        
        <p>In this article I'm going to discuss how to price a certain type of <em>Exotic</em> option known as a <strong>Path-Dependent Asian</strong> in C++ using Monte Carlo Methods. It is considered "exotic" in the sense that the pay-off is a function of the underlying asset at multiple points throughout its lifetime, rather than just the value at expiry. An Asian option actually utilises the mean of the underlying asset price sampled at appropriate intervals as the basis for its pay-off, which is where the "path-dependency" of the asset comes from. The name actually arises because they were first devised in 1987 in Tokyo as options on crude oil futures.</p>

<p>There are two types of Asian option that we will be pricing. They are the <em>arithmetic Asian</em> and the <em>geometric Asian</em>. They differ only in how the mean of the underlying values is calculated.  We will be studying discrete Asian options in this article, as opposed to the theoretical continuous Asian options. The first step will be to break down the components of the program and construct a set of classes that represent the various aspects of the pricer. Before that however, I will brief explain how Asian options work (and are priced by Monte Carlo).</p>

<h2>Overview of Asian Options</h2>

<p>An Asian option is a type of <em>exotic</em> option. Unlike a vanilla European option where the price of the option is dependent upon the price of the underlying asset at expiry, an Asian option pay-off is a function of multiple points up to and including the price at expiry. Thus it is <em>path-dependent</em> as the price relies on knowing how the underlying behaved at certain points <em>before</em> expiry. Asian options in particular base their price off the <em>mean average</em> price of these sampled points. To simplify this article we will consider $N$ equally distributed sample points beginning at time $t=0$ and ending at maturity, $T$.</p>

<p>Unlike in the <a href="http://quantstart.com/articles/European-vanilla-option-pricing-with-C-via-Monte-Carlo-methods">vanilla European option Monte Carlo case</a>, where we only needed to generate multiple spot values at expiry, we now need to generate multiple spot <em>paths</em>, each sampled at the correct points. Thus instead of providing a <code>double</code> value representing spot to our option, we now need to provide a <code>std::vector&lt;double&gt;</code> (i.e. a vector of double values), each element of which represents a sample of the spot price on a particular path. We will still be modelling our asset price path via a <a href="http://quantstart.com/articles/Geometric-Brownian-Motion">Geometric Brownian Motion</a> (GBM), and we will create each path by adding the correct drift and variance at each step in order to maintain the properties of GBM.</p>

<p>In order to calculate the arithmetic mean $A$ of the spot prices we use the following formula:</p>

\begin{eqnarray*}
A(0,T) = \frac{1}{N} \sum^{N}_{i=1} S(t_i) 
\end{eqnarray*}

<p>Similarly for the geometric mean:</p>

\begin{eqnarray*}
A(0,T) = \exp\left(\frac{1}{N} \sum^{N}_{i=1} \log(S(t_i)) \right)
\end{eqnarray*}

<p>These two formulae will then form the basis of our <code>pay_off_price</code> method, which is attached to our <code>AsianOption</code> class.</p>

<h2>Asian Options - An Object Oriented Approach</h2>

<p>In order to increase maintainability we will separate the components of the Asian options pricer. We are able to create an <em>abstract base class</em> called <code>PayOff</code>, which defines an interface that all subsequent inherited pay-off classes will implement. The major benefit of this approach is that we can encapsulate multiple various types of pay-off functionality without the need to modify the remaining classes, such as our AsianOption class (to be discussed below). We make use of the <code>operator()</code> to turn our pay-off classes into a <em>functor</em> (i.e. a function object). This means that we can "call" the object just as we would a function. "Calling" a <code>PayOff</code> object has the effect of calculating the pay-off and returning it.</p>

<p>Here is the declaration for the <code>PayOff</code> base class:</p>

<pre>
<code class="language-cpp">class PayOff {
 public:
  PayOff(); // Default (no parameter) constructor
  virtual ~PayOff() {}; // Virtual destructor

  // Overloaded () operator, turns the PayOff into an abstract function object
  virtual double operator() (const double& S) const = 0;
};</code>
</pre>

<p>The second class will represent many aspects of the exotic path-dependent Asian option. This class will be called <code>AsianOption</code>. It will once again be an abstract base class (which means that it contains at least one <em>pure virtual function</em>). Since there are many types of Asian option - arithmetic, geometric, continuous, discrete - we will once again make use of the inheritance hierarchy. In particular, we will override the <code>pay_off_price</code> function, which determines how the mean pay-off is to be calculated, once the appropriate <code>PayOff</code> object has been provided.</p>

<p>Here is the declaration for the <code>AsianOption</code> base class:</p>

<pre>
<code class="language-cpp">class AsianOption {
 protected:
  PayOff* pay_off;  // Pay-off class (in this instance call or put) 

 public:
  AsianOption(PayOff* _pay_off);
  virtual ~AsianOption() {};

  // Pure virtual pay-off operator (this will determine arithmetic or geometric)
  virtual double pay_off_price(const std::vector&lt;double&gt;& spot_prices) const = 0;
};</code>
</pre>

<p>In C++ there is always a trade-off between simplicity and extensibility. More often than not a program must become more complicated if it is to be extendable elsewhere. Thus we have the choice of creating a separate object to handle the path generation used by the Asian option or write it procedurally. In this instance I have elected to use a procedural approach because I don't feel that delving into the complexities of random number generation classes has a beneficial effect on learning how Asian options are priced <em>at this stage</em>. In later articles we will encapsulate the random number and path generation, but right now we will <strong>keep it simple</strong>.</p>

<h2>Pay-Off Classes</h2>

<p>The first class we will consider is the <code>PayOff</code>. As stated above this is an abstract base class and so can never be instantiated directly. Instead it provides an <em>interface</em> through which all inherited classes will be bound to. The destructor is <code>virtual</code> to <a href="http://quantstart.com/articles/C-Virtual-Destructors-How-to-Avoid-Memory-Leaks">avoid memory leaks when the inherited and base classes are destroyed</a>. We'll take a look at the full listing for the <code>payoff.h</code> header file and then step through the important sections:</p>

<pre>
<code class="language-cpp">#ifndef __PAY_OFF_HPP
#define __PAY_OFF_HPP

#include &lt;algorithm&gt; // This is needed for the std::max comparison function, used in the pay-off calculations

class PayOff {
 public:
  PayOff(); // Default (no parameter) constructor
  virtual ~PayOff() {}; // Virtual destructor

  // Overloaded () operator, turns the PayOff into an abstract function object
  virtual double operator() (const double& S) const = 0;
};

class PayOffCall : public PayOff {
 private:
  double K; // Strike price

 public:
  PayOffCall(const double& K_);
  virtual ~PayOffCall() {};

  // Virtual function is now over-ridden (not pure-virtual anymore)
  virtual double operator() (const double& S) const;
};

class PayOffPut : public PayOff {
 private:
  double K; // Strike

 public:
  PayOffPut(const double& K_);
  virtual ~PayOffPut() {};
  virtual double operator() (const double& S) const;
};

#endif</code>
</pre>

<p>The declaration for the <code>PayOff</code> class is straightforward except for the overload of <code>operator()</code>. The syntax says that this method cannot be implemented within this class (<code>= 0</code>) and that it should be overridden by an inherited class (<code>virtual</code>). It is also a <code>const</code> method as it does not modify anything. It simply takes a spot price $S$ and returns the option pay-off, for a given strike, $K$:</p>

<pre>
<code class="language-cpp">// Overloaded () operator, turns the PayOff into an abstract function object
virtual double operator() (const double& S) const = 0;</code>
</pre>

<p>Beyond the <code>PayOff</code> class we implement the <code>PayOffCall</code> and <code>PayOffPut</code> classes which implement call and put functionality. We could also introduce digital and double digital pay-off classes here, but for the purposes of demonstrating Asian options, I will leave that as an exercise! Notice now that in each of the declarations of the <code>operator()</code> the <code>= 0</code> pure virtual declaration has been removed. This states that the methods should be implemented by these classes:</p>

<pre>
<code class="language-cpp">// Virtual function is now over-ridden (not pure-virtual anymore)
virtual double operator() (const double& S) const;</code>
</pre>

<p>That sums up the header file for the <code>PayOff</code> class hierarchy. We will now look at the source file (below) and then step through the important sections:</p> 

<pre>
<code class="language-cpp">#ifndef __PAY_OFF_CPP
#define __PAY_OFF_CPP

#include "payoff.h"

PayOff::PayOff() {}

// ==========
// PayOffCall
// ==========

// Constructor with single strike parameter
PayOffCall::PayOffCall(const double& _K) { K = _K; }

// Over-ridden operator() method, which turns PayOffCall into a function object
double PayOffCall::operator() (const double& S) const {
  return std::max(S-K, 0.0); // Standard European call pay-off
}

// =========
// PayOffPut
// =========

// Constructor with single strike parameter
PayOffPut::PayOffPut(const double& _K) {
  K = _K;
}

// Over-ridden operator() method, which turns PayOffPut into a function object
double PayOffPut::operator() (const double& S) const {
  return std::max(K-S, 0.0); // Standard European put pay-off
}

#endif</code>
</pre>

<p>The only major point of note within the source file is the implementation of the call and put <code>operator()</code> methods. They make use of the <code>std::max</code> function found within the <code>&lt;algorithm&gt;</code> standard library:</p>

<pre>
<code class="language-cpp">// Over-ridden operator() method, which turns PayOffCall into a function object
double PayOffCall::operator() (const double& S) const {
  return std::max(S-K, 0.0); // Standard European call pay-off
}

..

// Over-ridden operator() method, which turns PayOffPut into a function object
double PayOffPut::operator() (const double& S) const {
  return std::max(K-S, 0.0); // Standard European put pay-off
}</code>
</pre>

<p>The concludes the <code>PayOff</code> class hierarchy. It is quite straightforward and we're not using any real advanced features beyond abstract base classes and pure virtual functions. However, we have written quite a lot of code to encapsulate something seemingly as simple as a simple pay-off function. The benefits of such an approach will become clear later on, when or if we decide we wish to create more complex pay-offs as we will not need to modify our <code>AsianOption</code> class to do so.</p>

<h2>Path Generation Header</h2>

<p>To generate the paths necessary for an Asian option we will use a procedural approach. Instead of encapsulating the random number generator and path generator in a set of objects, we will make use of two functions, one of which generates the random Gaussian numbers (via the Box-Muller method) and the other which takes these numbers and generates sampled Geometric Brownian Motion asset paths for use in the <code>AsianOption</code> object. The article on <a href="http://quantstart.com/articles/European-vanilla-option-pricing-with-C-via-Monte-Carlo-methods">European option pricing via Monte Carlo</a> explains the concept of risk-neutral pricing, Monte Carlo techniques and the Box-Muller method. I have included the full function in the listing below for completeness.</p>

<p>The second function, <code>calc_path_spot_prices</code> is more relevant. It takes a reference to a vector of doubles (<code>std::vector&lt;double&gt;&</code>) and updates it to reflect a random spot path based on a set of random Gaussian increments of the asset price. I will show the full listing for the header file which contains these functions, then I will step through <code>calc_path_spot_prices</code> in detail:</p>

<pre>
<code class="language-cpp">#ifndef __PATH_GENERATION_H
#define __PATH_GENERATION_H

#include &lt;vector&gt;
#include &lt;cmath&gt;

// For random Gaussian generation
// Note that there are many ways of doing this, but we will
// be using the Box-Muller method for demonstration purposes
double gaussian_box_muller() {
  double x = 0.0;
  double y = 0.0;
  double euclid_sq = 0.0;

  do {
    x = 2.0 * rand() / static_cast&lt;double&gt;(RAND_MAX)-1;
    y = 2.0 * rand() / static_cast&lt;double&gt;(RAND_MAX)-1;
    euclid_sq = x*x + y*y;
  } while (euclid_sq >= 1.0);

  return x*sqrt(-2*log(euclid_sq)/euclid_sq);
}

// This provides a vector containing sampled points of a 
// Geometric Brownian Motion stock price path
void calc_path_spot_prices(std::vector&lt;double&gt;& spot_prices,  // Vector of spot prices to be filled in
                           const double& r,   // Risk free interest rate (constant)
                           const double& v,   // Volatility of underlying (constant)
                           const double& T) { // Expiry
  // Since the drift and volatility of the asset are constant
  // we will precalculate as much as possible for maximum efficiency
  double dt = T/static_cast&lt;double&gt;(spot_prices.size());
  double drift = exp(dt*(r-0.5*v*v));
  double vol = sqrt(v*v*dt);

  for (int i=1; i&lt;spot_prices.size(); i++) {
    double gauss_bm = gaussian_box_muller();
    spot_prices[i] = spot_prices[i-1] * drift * exp(vol*gauss_bm);
  }
}

#endif</code>
</pre>

<p>Turning our attention to <code>calc_path_spot_prices</code> we can see that the function requires a vector of doubles, the risk-free rate $r$, the volatility of the underlying $\sigma$ and the time at expiry, $T$:</p>

<pre>
<code class="language-cpp">void calc_path_spot_prices(std::vector&lt;double&gt;& spot_prices,  // Vector of spot prices to be filled in
                           const double& r,   // Risk free interest rate (constant)
                           const double& v,   // Volatility of underlying (constant)
                           const double& T) { // Expiry</code>
</pre>

<p>Since we are dealing with constant increments of time for our path sampling frequency we need to calculate this increment. These increments are always identical so in actual fact it can be pre-calculated outside of the loop for the spot price path generation. Similarly, via the properties of Geometric Brownian Motion, we know that we can increment the drift and variance of the asset in a manner which can be pre-computed. The only difference between this increment and the European case is that we are replacing $T$ with $dt$ for each subsequent increment of the path. See the <a href="http://quantstart.com/articles/European-vanilla-option-pricing-with-C-via-Monte-Carlo-methods">European option pricing article</a> for a comparison:</p>

<pre>
<code class="language-cpp">double dt = T/static_cast&lt;double&gt;(spot_prices.size());
double drift = exp(dt*(r-0.5*v*v));
double vol = sqrt(v*v*dt);</code>
</pre>

<p>The final part of the function calculates the new spot prices by iterating over the <code>spot_price</code> vector and adding the drift and variance to each piece. We are using the arithmetic of logarithms here, and thus can <em>multiply</em> by our drift and variance terms, since it is the <em>log of the asset price</em> that is subject to normally distributed increments in Geometric Brownian Motion. Notice that the loop runs from $i=1$, not $i=0$. This is because the <code>spot_price</code> vector is already pre-filled with $S$, the initial spot, elsewhere in the program:</p>

<pre>
<code class="language-cpp">for (int i=1; i&lt;spot_prices.size(); i++) {
  double gauss_bm = gaussian_box_muller();
  spot_prices[i] = spot_prices[i-1] * drift * exp(vol*gauss_bm);
}</code>
</pre>

<p>That concludes the path-generation header file. Now we'll take a look at the <code>AsianOption</code> classes themselves.</p>

<h2>Asian Option Classes</h2>

<p>The final component of our program (besides the <code>main</code> file of course!) is the Asian option inheritance hierarchy. We wish to price multiple types of Asian option, including geometric Asian options and arithmetic Asian options. One way to achieve this is to have separate methods on an <code>AsianOption</code> class. However this comes at the price of having to continually add more methods if we wish to make more granular changes to our <code>AsianOption</code> class. In a production environment this would become unwieldy. Instead we can use the abstract base class approach and generate an abstract <code>AsianOption</code> class with a pure virtual method for <code>pay_off_price</code>. This method is implemented in subclasses and determines how the averaging procedure for the asset prices over the asset path lifetime will occur. Two publicly-inherited subclasses <code>AsianOptionArithmetic</code> and <code>AsianOptionGeometric</code> implement this method.</p>

<p>Let's take a look at the full listing for the header declaration file and then we'll step through the interesting sections:</p>

<pre>
<code class="language-cpp">#ifndef __ASIAN_H
#define __ASIAN_H

#include &lt;vector&gt;
#include "payoff.h"

class AsianOption {
 protected:
  PayOff* pay_off;  // Pay-off class (in this instance call or put) 

 public:
  AsianOption(PayOff* _pay_off);
  virtual ~AsianOption() {};

  // Pure virtual pay-off operator (this will determine arithmetic or geometric)
  virtual double pay_off_price(const std::vector&lt;double&gt;& spot_prices) const = 0;
};

class AsianOptionArithmetic : public AsianOption {
 public:
  AsianOptionArithmetic(PayOff* _pay_off);
  virtual ~AsianOptionArithmetic() {};
  
  // Override the pure virtual function to produce arithmetic Asian Options
  virtual double pay_off_price(const std::vector&lt;double&gt;& spot_prices) const;
};

class AsianOptionGeometric : public AsianOption {
 public:
  AsianOptionGeometric(PayOff* _pay_off);
  virtual ~AsianOptionGeometric() {};

  // Overide the pure virtual function to produce geometric Asian Options
  virtual double pay_off_price(const std::vector&lt;double&gt;& spot_prices) const;
};

#endif</code>
</pre>

<p>The first thing to notice about the abstract <code>AsianOption</code> class is that it has a pointer to a <code>PayOff</code> class as a protected member:</p>

<pre>
<code class="language-cpp">protected:
 PayOff* pay_off;  // Pay-off class (in this instance call or put)</code>
</pre>

<p>This is an example of <em>polymorphism</em>. The object will not know what type of <code>PayOff</code> class will be passed in. It could be a <code>PayOffCall</code> or a <code>PayOffPut</code>. Thus we can use a pointer to the <code>PayOff</code> abstract class to represent "storage" of this as-yet-unknown <code>PayOff</code> class. Note also that the constructor takes this as its only parameter:</p>

<pre>
<code class="language-cpp">public:
 AsianOption(PayOff* _pay_off);</code>
</pre>

<p>Finally we have the declaration for the pure virtual <code>pay_off_price</code> method. This takes a vector of spot prices, but notice that it is passed as a reference to <code>const</code>, so this vector will not be modified within the method:</p>

<pre>
<code class="language-cpp">// Pure virtual pay-off operator (this will determine arithmetic or geometric)
virtual double pay_off_price(const std::vector&lt;double&gt;& spot_prices) const = 0;</code>
</pre>

<p>The listings for the <code>AsianOptionArithmetic</code> and <code>AsianOptionGeometric</code> classes are analogous to those in the <code>PayOff</code> hierarchy, with the exception that their constructors take a pointer to a <code>PayOff</code> object. That concludes the header file.</p>

<p>The source file essentially implements the two <code>pay_off_price</code> methods for the inherited subclasses of <code>AsianOption</code>:</p>

<pre>
<code class="language-cpp">#ifndef __ASIAN_CPP
#define __ASIAN_CPP

#include &lt;numeric&gt;  // Necessary for std::accumulate
#include &lt;cmath&gt;  // For log/exp functions
#include "asian.h"

// =====================
// AsianOptionArithmetic
// =====================

AsianOption::AsianOption(PayOff* _pay_off) : pay_off(_pay_off) {}

// =====================  
// AsianOptionArithmetic
// =====================  

AsianOptionArithmetic::AsianOptionArithmetic(PayOff* _pay_off) : AsianOption(_pay_off) {}

// Arithmetic mean pay-off price
double AsianOptionArithmetic::pay_off_price(const std::vector<double>& spot_prices) const {
  unsigned num_times = spot_prices.size();
  double sum = std::accumulate(spot_prices.begin(), spot_prices.end(), 0);
  double arith_mean = sum / static_cast&lt;double&gt;(num_times);
  return (*pay_off)(arith_mean);
}

// ====================
// AsianOptionGeometric
// ====================

AsianOptionGeometric::AsianOptionGeometric(PayOff* _pay_off) : AsianOption(_pay_off) {}

// Geometric mean pay-off price
double AsianOptionGeometric::pay_off_price(const std::vector<double>& spot_prices) const {
  unsigned num_times = spot_prices.size();
  double log_sum = 0.0;
  for (int i=0; i&lt;spot_prices.size(); i++) {
    log_sum += log(spot_prices[i]);
  }
  double geom_mean = exp(log_sum / static_cast&lt;double&gt;(num_times) );
  return (*pay_off)(geom_mean);
}

#endif</code>
</pre>

<p>Let's take a look at the arithmetic option version. First of all we determine the number of sample points via the size of the <code>spot_price</code> vector. Then we use the <code>std::accumulate</code> algorithm and iterator syntax to sum the spot values in the vector. Finally we take the arithmetic mean of those values and use pointer dereferencing to call the <code>operator()</code> for the <code>PayOff</code> object. For this program it will provide a call or a put pay-off function for the average of the spot prices:</p>

<pre>
<code class="language-cpp">double AsianOptionArithmetic::pay_off_price(const std::vector<double>& spot_prices) const {
  unsigned num_times = spot_prices.size();
  double sum = std::accumulate(spot_prices.begin(), spot_prices.end(), 0);
  double arith_mean = sum / static_cast&lt;double&gt;(num_times);
  return (*pay_off)(arith_mean);
}</code>
</pre>

<p>The geometric Asian is similar. We once again determine the number of spot prices. Then we loop over the spot prices, summing the logarithm of each of them and adding it to the grand total. Then we take the geometric mean of these values and finally use pointer dereferencing once again to determine the correct call/put pay-off value:</p>

<pre>
<code class="language-cpp">double AsianOptionGeometric::pay_off_price(const std::vector<double>& spot_prices) const {
  unsigned num_times = spot_prices.size();
  double log_sum = 0.0;
  for (int i=0; i&lt;spot_prices.size(); i++) {
    log_sum += log(spot_prices[i]);
  }
  double geom_mean = exp(log_sum / static_cast&lt;double&gt;(num_times) );
  return (*pay_off)(geom_mean);
}</code>
</pre>

<p>Note here what the <code>AsianOption</code> classes <em>do not</em> require. Firstly, they don't require information about the underlying (i.e. vol). They also don't require time to expiry or the interest rate. Thus we are really trying to encapsulate the <em>term sheet</em> of the option in this object, i.e. all of the parameters that would appear on the contract when the option is made. However, for simplicity we have neglected to include the actual <em>sample times</em>, which would also be written on the contract. This instead is moved to the path-generator. However, later code will amend this, particularly as we can re-use the <code>AsianOption</code> objects in more sophisticated programs, where interest rates and volatility are subject to stochastic models.</p>

<h2>The Main Program</h2>

<p>The final part of the program is the <code>main.cpp</code> file. It brings all of the previous components together to produce an output for the option price based on some default parameters. The full listing is below:</p>

<pre>
<code class="language-cpp">#include &lt;iostream&gt;

#include "payoff.h"
#include "asian.h"
#include "path_generate.h"

int main(int argc, char **argv) {
  // First we create the parameter list
  // Note that you could easily modify this code to input the parameters
  // either from the command line or via a file
  unsigned num_sims = 100000;   // Number of simulated asset paths
  unsigned num_intervals = 250;  // Number of intervals for the asset path to be sampled 
  double S = 30.0;  // Option price
  double K = 29.0;  // Strike price
  double r = 0.08;   // Risk-free rate (8%)
  double v = 0.3;    // Volatility of the underlying (30%)
  double T = 1.00;    // One year until expiry
  std::vector&lt;double&gt; spot_prices(num_intervals, S);  // The vector of spot prices

  // Create the PayOff objects
  PayOff* pay_off_call = new PayOffCall(K);

  // Create the AsianOption objects
  AsianOptionArithmetic asian(pay_off_call);

  // Update the spot price vector with correct 
  // spot price paths at constant intervals
  double payoff_sum = 0.0;
  for (int i=0; i&lt;num_sims; i++) {
    calc_path_spot_prices(spot_prices, r, v, T);
    payoff_sum += asian.pay_off_price(spot_prices);
  }
  double discount_payoff_avg = (payoff_sum / static_cast&lt;double&gt;(num_sims)) * exp(-r*T);

  delete pay_off_call;

  // Finally we output the parameters and prices
  std::cout &lt;&lt; "Number of Paths: " &lt;&lt; num_sims &lt;&lt; std::endl;
  std::cout &lt;&lt; "Number of Ints:  " &lt;&lt; num_intervals &lt;&lt; std::endl;
  std::cout &lt;&lt; "Underlying:      " &lt;&lt; S &lt;&lt; std::endl;
  std::cout &lt;&lt; "Strike:          " &lt;&lt; K &lt;&lt; std::endl;
  std::cout &lt;&lt; "Risk-Free Rate:  " &lt;&lt; r &lt;&lt; std::endl;
  std::cout &lt;&lt; "Volatility:      " &lt;&lt; v &lt;&lt; std::endl;
  std::cout &lt;&lt; "Maturity:        " &lt;&lt; T &lt;&lt; std::endl;

  std::cout &lt;&lt; "Asian Price:     " &lt;&lt; discount_payoff_avg &lt;&lt; std::endl;

  return 0;
}</code>
</pre>

<p>The first interesting aspect of the <code>main.cpp</code> program is that we have now added a <code>unsigned num_intervals = 250;</code> line which determines how frequently the spot price will be sampled in the Asian option. As stated above, this would usually be incorporated into the option <em>term sheet</em>, but I have included it here instead to help make the pricer easier to understand without too much object communication overhead. We have also created the vector of spot prices, which are pre-filled with the default spot price, $S$:</p>

<pre>
<code class="language-cpp">unsigned num_intervals = 250;  // Number of intervals for the asset path to be sampled 
..
std::vector&lt;double&gt; spot_prices(num_intervals, S);  // The vector of spot prices</code>
</pre>

<p>Then we create a <code>PayOffCall</code> object and assign it to a <code>PayOff</code> pointer. This allows us to leverage <em>polymorphism</em> and pass that object through to the <code>AsianOption</code>, without the option needing to know the actual type of <code>PayOff</code>. <em>Note that whenever we use the <code>new</code> operator, we must make use of the corresponding <code>delete</code> operator.</em></p>

<pre>
<code class="language-cpp">PayOff* pay_off_call = new PayOffCall(K);
..
delete pay_off_call;</code>
</pre>

<p>The next step is to create the <code>AsianOptionArithmetic</code> object. We could have as easily chosen the <code>AsianOptionGeometric</code> and the program would be trivial to modify to do so. It takes in the pointer to the <code>PayOff</code> as its lone constructor argument:</p>

<pre>
<code class="language-cpp">AsianOptionArithmetic asian(pay_off_call);</code>
</pre>

<p>Then we create a loop for the total number of path simulations. In the loop we recalculate a new spot price path and then add that pay-off to a running sum of all pay-offs. The final step is to discount the average of this pay-off via the risk-free rate across the lifetime of the option ($T-0 = T$). This discounted price is then the final price of the option, with the above parameters:</p>

<pre>
<code class="language-cpp">double payoff_sum = 0.0;
for (int i=0; i&lt;num_sims; i++) {
  calc_path_spot_prices(spot_prices, r, v, T);
  payoff_sum += asian.pay_off_price(spot_prices);
}
double discount_payoff_avg = (payoff_sum / static_cast&lt;double&gt;(num_sims)) * exp(-r*T);</code>
</pre>

<p>The final stage of the main program is to output the parameters and the options price:</p>

<pre>
<code class="language-none">Number of Paths: 100000
Number of Ints:  250
Underlying:      30
Strike:          29
Risk-Free Rate:  0.08
Volatility:      0.3
Maturity:        1
Asian Price:     2.85425</code>
</pre>

<p>The benefits of such an object-oriented approach are now clear. We can easily add more <code>PayOff</code> or <code>AsianOption</code> classes without needing to extensively modify any of the remaining code. These objects are said to have a <em>separation of concerns</em>, which is exactly what is needed for large-scale software projects.</p>

<p>That is not to say that the program could not be improved! One obvious task is to determine how to incorporate the number of stock samples - and interval spacing - within the <code>AsianOption</code> hierarchy. Another is to encapsulate the random number and path generation into its own "engine" that can be used in other option pricers.</p>

<p>As always, if you have any difficulty following the above, please feel free to email me at <a href="mailto:support@quanstart"><strong>support@quantstart.com</strong></a>.</p>
        
        
        <script async data-uid="6296c27f4b" src="https://weathered-brook-5281.ck.page/6296c27f4b/index.js"></script>
      </section>
    </div>
    <div class="col-md-4 book-card order-md-1">
      
<div class="sidebar-advert-container">
  <a href="/qsalpha/?ref=art">
    <img class="card-img-top" src="/static/images/qsalpha-sidebar-advert-small.png" alt="QSAlpha">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/qsalpha/?ref=art">QSAlpha</a></h3>
      <p class="card-text medium-text mb-3">Join the QSAlpha research platform that helps fill your strategy research pipeline, diversifies your portfolio and improves your risk-adjusted returns for increased profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/qsalpha/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/quantcademy/?ref=art">
    <img class="card-img-top" src="/static/images/quantcademy-sidebar-advert-small.png" alt="Quantcademy">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/quantcademy/?ref=art">The Quantcademy</a></h3>
      <p class="card-text medium-text mb-3">Join the Quantcademy membership portal that caters to the rapidly-growing retail quant trader community and learn how to increase your strategy profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/quantcademy/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/successful-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/sat-sidebar-advert-small.png" alt="Successful Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to find new trading strategy ideas and objectively assess them for your portfolio using a Python-based backtesting engine.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/successful-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/advanced-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/aat-sidebar-advert-small.png" alt="Advanced Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to implement advanced trading strategies using time series analysis, machine learning and Bayesian statistics with R and Python.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/advanced-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>
</div>
    </div>
  </div>
</section>

    

<footer>
  <div class="container container-full">
    <section class="mt-1.5 mb-1">
      <div class="row">
        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">QuantStart</li>
            <li class="footer-list-link"><a class="link-fade" href="/about/">About</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/articles/">Articles</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/sitemap/">Sitemap</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Products</li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qsalpha/">QSAlpha</a></li>
            
            
            <li class="footer-list-link"><a class="link-fade" href="/quantcademy/">Quantcademy</a></li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qstrader/">QSTrader</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Legal</li>
            <li class="footer-list-link"><a class="link-fade" href="/privacy-policy/">Privacy Policy</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/terms-and-conditions/">Terms &amp; Conditions</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Social</li>
            <li class="footer-list-link"><a class="link-fade" href="https://twitter.com/quantstart">Twitter</a></li>
            <li class="footer-list-link"><a class="link-fade" href="https://www.youtube.com/channel/UCmVnnZ6Y2TrJtY1eQJN6kWA">YouTube</a></li>
          </ul>
        </div>
      </div>
    </section>

    <div class="row mb-1.5 mt-5">
      <div class="col-12 col-md-9 col-lg-8 col-xl-6">
        <div class="footer-copyright">
          <p>©2012-2023 QuarkGluon Ltd. All rights reserved.</p>
        </div>
      </div>
    </div>
  </div>
</footer>

    
<script src="/static/js/jquery-3.2.1.min.js"></script>
<script src="/static/js/prism.js.min"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/nav.js"></script>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5383959-5']);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="/static/js/highcharts/highcharts.js"></script>
<script type="text/javascript">
  num_colours = 10;
</script>
<script src="/static/js/statistics.js"></script>


  </body>
</html>
