
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="google-site-verification" content="wl3-8ed1QZjI0iYZMv10zoZWYElkMObTfwLlWIj9cpA" />
    <meta name="description" content="Aluminum Smelting Cointegration Strategy in QSTrader">

    <link rel="icon" href="/static/images/favicon.png">

    <title>Aluminum Smelting Cointegration Strategy in QSTrader | QuantStart</title>
    
    
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,900&display=swap" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900&display=swap" rel="stylesheet"> 
<link href="/static/css/bootstrap.min.css" rel="stylesheet">
<link href="/static/css/prism.css" rel="stylesheet">
<link href="/static/css/qs.css?v=10" rel="stylesheet">
    
  </head>

  <body>
    <header class="header covered-header" style="background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url(https://quantstartmedia.s3.amazonaws.com/images/article-images/article-backgrounds/default-bg.jpg);">
  
<nav class="nav">
  <div class="container nav-container">
    <div class="nav-row row d-flex justify-content-between align-items-center">
      <div class="col-2">
        <ul class="nav-items justify-content-end small-capitals align-items-center">
          <li class="nav-item">
            <a class="link-fade" href="/">QuantStart</a>
          </li>
        </ul>
      </div>
      <div class="col-auto col-logo">
        <ul id="top-nav-menu" class="nav-items justify-content-end align-items-center">
          
          <li class="nav-item">
            <a class="link-fade" href="/qsalpha/">QSAlpha</a>
          </li>
          
          
          <li class="nav-item">
            <a class="link-fade" href="/quantcademy/">Quantcademy</a>
          </li>
          
          <li id="menu-link-ebooks" class="nav-item">
            <a class="link-fade" href="#">Books</a>
            <div id="menu-pane-ebooks" class="nav-items menu-dropdown-pane">
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
              </div>
              <div class="nav-item">
                <a class="link-fade d-block ml-3 mr-3 my-3 mt-4" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
              </div>
            </div>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/qstrader/">QSTrader</a>
          </li>
          <li class="nav-item">
            <a class="link-fade" href="/articles/">Articles</a>
          </li>
          
          <li class="nav-item">
            <a class="link-fade" href="/members/login/">Login</a>
          </li>
          
        </ul>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
    </div>
  </div>
</nav>

<nav id="mobile-nav" class="mobile-nav text-left">
  <div class="container">
    <ul class="mt-4 ml-3 mobile-nav-menu">
      <li class="nav-item">
        <a class="link-fade d-block" href="/">QuantStart</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qsalpha/">QSAlpha</a>
      </li>
      

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/quantcademy/">Quantcademy</a>
      </li>
      

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="#">Books</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a>
      </li>
      <li class="nav-item sub-item">
        <a class="link-fade d-block ml-3" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/qstrader/">QSTrader</a>
      </li>

      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/articles/">Articles</a>
      </li>

      
      <li class="nav-item">
        <a class="link-fade d-block pt-3" href="/members/login/">Login</a>
      </li>
      
    </ul>
    <button class="nav-toggle mobile-nav-close">
      <svg id="mobile-nav-close-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19.77,5.63,13.41,12l6.36,6.37a1,1,0,0,1-1.41,1.41L12,13.41,5.63,19.77a1,1,0,0,1-1.44-1.39l0,0L10.58,12,4.21,5.63a1,1,0,0,1,0-1.42,1,1,0,0,1,1.41,0l0,0L12,10.58l6.37-6.37a1,1,0,0,1,1.41,0A1,1,0,0,1,19.77,5.63Z"></path>
      </svg>
    </button>
  </div>
</nav>

  <div class="container hero-container">
    <section class="mt-5 mb-4">
      <div class="row justify-content-center">
        <div class="col-12 text-center">
          <p class="hero">Aluminum Smelting Cointegration Strategy in QSTrader</p>
          <p class="hero subhero">Aluminum Smelting Cointegration Strategy in QSTrader</p>
        </div>
      </div>
    </section>
  </div>
</header>
    
<section class="container content-container">
  <div class="row">
    <div class="col-md-8 order-md-2">
      <section class="content article-content">
        
        
        <p>In previous articles the concept of <a href="https://www.quantstart.com/articles/Cointegrated-Time-Series-Analysis-for-Mean-Reversion-Trading-with-R">cointegration</a> was considered. It was shown how cointegrated pairs of equities or ETFs could lead to profitable mean-reverting trading opportunities.</p>

<p>Two specific tests were outlined–the <a href="https://www.quantstart.com/articles/Cointegrated-Augmented-Dickey-Fuller-Test-for-Pairs-Trading-Evaluation-in-R">Cointegrated Augmented Dickey-Fuller (CADF) test</a> and the <a href="https://www.quantstart.com/articles/Johansen-Test-for-Cointegrating-Time-Series-Analysis-in-R">Johansen test</a>–that helped statistically identify cointegrated portfolios.</p>

<p>In this article <a href="https://www.quantstart.com/qstrader">QSTrader</a> will be used to implement an actual trading strategy based on a (potentially) cointegrating relationship between an equity and an ETF in the commodities market.</p>

<p>The analysis will begin by forming a hypothesis about a fundamental structural relationship between the prices of Alcoa Inc., a large aluminum producer, and US natural gas. This structural relationship will be tested for cointegration via the CADF test using R. It will be shown that although the prices appear partially correlated, that the null hypothesis of no cointegrating relationship cannot be rejected.</p>

<p>Despite this a static hedging ratio will be calculated between the two series and a trading strategy developed, firstly to show how such a strategy might be implemented in QSTrader, irrespective of performance, and secondly to evalulate the performance on a slightly correlated, but non-cointegrating pair of assets.</p>

<p><em>This strategy was inspired by Ernie Chan's famous GLD-GDX cointegration strategy<sup><a href="#ref-chan2013">[1]</a></sup> and a post<sup><a href="#ref-fawcett2012">[2]</a></sup> by Quantopian CEO, John Fawcett, referencing the smelting of aluminum as a potential for cointegrated assets.</em></p>

<h2>The Hypothesis</h2>

<p>An extremely important set of processes in chemical engineering are the <a href="https://en.wikipedia.org/wiki/Bayer_process">Bayer process</a> and the <a href="https://en.wikipedia.org/wiki/Hall%E2%80%93H%C3%A9roult_process">Hall–Héroult process</a>. They are the key steps in smelting aluminum from the raw mineral of bauxite, via the technique of <a href="https://en.wikipedia.org/wiki/Electrolysis">electrolysis</a>.</p>

<p style="text-align:center;">
  <img width="100%" src="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-aluminum-smelter.jpg">
</p>

<p>Electrolysis requires a substantial amount of electricity, much of which is generated by coal, hydroelectric, nuclear or <a href="https://en.wikipedia.org/wiki/Gas_turbine#Industrial_gas_turbines_for_power_generation">combined-cycle gas turbine (CCGT)</a> power. The latter requires natural gas as its main fuel source. Since the purchase of natural gas for aluminum smelting is likely a substantial cost for aluminum producers, their profitability is derived in part from the price of natural gas.</p>

<p>The hypothesis presented here is that the stock price of a large aluminum producer, such as Alcoa Inc. (ARNC) and that of an ETF representing US natural gas prices, such as UNG might well be cointegrated and thus lead to a potential mean-reverting systematic trading strategy.</p>

<h2>Cointegration Tests in R</h2>

<p>If you need a refresher on the topic of cointegration then please take a look at the following articles:</p>

<ul>
  <li><a href="https://www.quantstart.com/articles/Cointegrated-Time-Series-Analysis-for-Mean-Reversion-Trading-with-R">Cointegrated Time Series Analysis for Mean Reversion Trading with R</a></li>
  <li><a href="https://www.quantstart.com/articles/Cointegrated-Augmented-Dickey-Fuller-Test-for-Pairs-Trading-Evaluation-in-R">Cointegrated Augmented Dickey Fuller Test for Pairs Trading Evaluation in R</a></li>
  <li><a href="https://www.quantstart.com/articles/Johansen-Test-for-Cointegrating-Time-Series-Analysis-in-R">Johansen Test for Cointegrating Time Series Analysis in R</a></li>
</ul>

<p>To test the above hypothesis the Cointegrated Augmented Dickey Fuller procedure will be carried out on ARNC and UNG using R. The procedure has been outlined in depth in the previous articles and so the code will be replicated here with less explanation.</p>

<p>The first task is to import the R <a href="http://www.quantmod.com/">quantmod</a> library, for data download, as well as the <code>tseries</code> library, for the ADF test. The daily bar data of ARNC and UNG is downloaded for the period November 11th 2014 to January 1st 2017. The data is then set to the adjusted close values (handling splits/dividends):</p>

<pre>
<code class="language-r">library("quantmod")
library("tseries")

## Obtain ARNC and UNG
getSymbols("ARNC", from="2014-11-11", to="2017-01-01")
getSymbols("UNG", from="2014-11-11", to="2017-01-01")

## Utilise the backwards-adjusted closing prices
aAdj = unclass(ARNC$ARNC.Adjusted)
bAdj = unclass(UNG$UNG.Adjusted)</code>
</pre>

<p>The following displays a plot of the prices of ARNC (blue) and UNG (red) over the period:</p>

<pre>
<code class="language-r">## Plot the ETF backward-adjusted closing prices
plot(aAdj, type="l", xlim=c(0, length(aAdj)), ylim=c(0.0, 45.0), xlab="November 11th 2014 to January 1st 2017", ylab="Backward-Adjusted Prices in USD", col="blue")
par(new=T)
plot(bAdj, type="l", xlim=c(0, length(bAdj)), ylim=c(0.0, 45.0), axes=F, xlab="", ylab="", col="red")
par(new=F)</code>
</pre>

<p style="text-align:center;">
  <a href="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-arnc-ung-plot.png">
    <img width="100%" src="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-arnc-ung-plot.png">
  </a>
</p>

<p>It can be seen that the prices of ARNC and UNG follow a broadly similar pattern, which trends downwards for 2015 and then stays flat for 2016. Displaying a scatterplot will provide a clearer picture of any potential correlation:</p>

<pre>
<code class="language-r">## Plot a scatter graph of the ETF adjusted prices
plot(aAdj, bAdj, xlab="ARNC Backward-Adjusted Prices", ylab="UNG Backward-Adjusted Prices")</code>
</pre>

<p style="text-align:center;">
  <a href="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-scatterplot.png">
    <img width="100%" src="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-scatterplot.png">
  </a>
</p>

<p>The scatterplot is more ambiguous. There is a slight partial positive correlation, as would be expected for a company that is heavily exposed to natural gas prices, but whether this is sufficient to allow a structural relationship is less clear.</p>

<p>By performing a linear regression between the two, a slope coefficient/hedging ratio is obtained:</p>

<pre>
<code class="language-r">## Carry out linear regression on the two price series
comb = lm(aAdj~bAdj)</code>
</pre>

<pre>
<code class="language-r">> comb

Call:
lm(formula = aAdj ~ bAdj)

Coefficients:
(Intercept)         bAdj  
     11.039        1.213 </code>
</pre>

<p>In the linear regression where UNG is the independent variable the slope is given by 1.213. The final task is to carry out the ADF test and determine whether there is any structural cointegrating relationship:</p>

<pre>
<code class="language-r">## Now we perform the ADF test on the residuals,
## or "spread" of the model, using a single lag order
> adf.test(comb$residuals, k=1)

    Augmented Dickey-Fuller Test

data:  comb$residuals
Dickey-Fuller = -2.5413, Lag order = 1, p-value = 0.3492
alternative hypothesis: stationary</code>
</pre>

<p>This analysis shows that there is <em>not</em> sufficient evidence to reject the null hypothesis of no cointegrating relationship. However, despite this it is instructive to continue implementing the strategy with the hedging ratio calculated above, for two reasons:</p>

<ol>
  <li>Firstly, any other potential cointegration-based analysis, as derived from the CADF or the Johansen test, can be backtested using the following code, as it has been written to be flexible enough to cope with large cointegrated portfolios.</li>
  <li>Secondly, it is valuable to see how a strategy performs when there is insufficient evidence to reject the null hypothesis. Perhaps the pair is still tradeable even though a relationship has not been detected on this small dataset.</li>
</ol>

<p>The trading strategy mechanism will now be outlined.</p>

<h2>The Trading Strategy</h2>

<p>In order to actually generate tradeable signals from a mean-reverting "spread" of prices from a linear combination of ARNC and UNG, a technique known as <a href="https://en.wikipedia.org/wiki/Bollinger_Bands">Bollinger Bands</a> will be utilised.</p>

<p>Bollinger Bands involve taking a rolling simple moving average of a price series and then forming "bands" surrounding the series that are a scalar multiple of the rolling standard deviation of the price series. The lookback period for the moving average and standard deviation is identical. In essence they are an estimate of current volatility of a price series.</p>

<p>By definition, a mean-reverting series will occasionally deviate from its mean and then eventually revert. Bollinger Bands provide a mechanism for entering and exiting trades by employing standard deviation "thresholds" at which trades can be entered into and exited from.</p>

<p>To generate trades the first task is to calculate a <a href="https://en.wikipedia.org/wiki/Standard_score">z-score/standard score</a> of the current latest spread price. This is achieved by taking the latest <em>portfolio</em> market price, subtracting the rolling mean and dividing by the rolling standard deviation (as described above).</p>

<p>Once this z-score is calculated a position will be opened or closed out under the following conditions:</p>

<ul>
  <li>$z_{\text{score}} \lt -z_{\text{entry}}$ - Long entry</li>
  <li>$z_{\text{score}} \gt +z_{\text{entry}}$ - Short entry</li>
  <li>$z_{\text{score}} \ge -z_{\text{exit}}$ - Long close</li>
  <li>$z_{\text{score}} \le +z_{\text{exit}}$ - Short close</li>
</ul>

<p>Where $z_{\text{score}}$ is the latest standardised spread price, $z_{\text{entry}}$ is the trade entry threshold and $z_{\text{exit}}$ is the trade exit threshold.</p>

<p>A longd position here means purchasing one share of ARNC and shorting 1.213 shares of UNG. Clearly it is impossible to trade a fractional number of shares! Hence such a fraction is rounded to the nearest integer when multiplied by a large unit base quantity (such as 10,000 "units" of the portfolio traded).</p>

<p>Thus profitable trades are likely to occur assuming that the above conditions are regularly met, which a cointegrating pair with high volatility should provide.</p>

<p>For this particular strategy the lookback period used for the rolling moving average and the rolling standard deviation is equal to 15 bars. $z_{\text{entry}}=1.5$, while $z_{\text{exit}}=0.5$. All of these parameters are arbitrarily picked for this article, but a full research project would optimise these via some form of parameter grid-search.</p>

<h2>Data</h2>

<p>In order to carry out this strategy it is necessary to have daily OHLCV pricing data for the equities and ETFs in the period covered by this backtest:</p>

<table class="table">
  <tr>
    <th>Ticker</th>
    <th>Name</th>
    <th>Period</th>
    <th>Link</th>
  </tr>
  <tr>
    <td>ARNC</td>
    <td>Arconic Inc. (prev Alcoa Inc.)</td>
    <td>11th November 2014 - 1st September 2016</td>
    <td><a href="http://chart.finance.yahoo.com/table.csv?s=ARNC&a=10&b=11&c=2014&d=0&e=11&f=2017&g=d&ignore=.csv">Yahoo Finance</a></td>
  </tr>
  <tr>
    <td>UNG</td>
    <td>United States Natural Gas ETF</td>
    <td>11th November 2014 - 1st September 2016</td>
    <td><a href="http://chart.finance.yahoo.com/table.csv?s=UNG&a=10&b=11&c=2014&d=0&e=11&f=2017&g=d&ignore=.csv">Yahoo Finance</a></td>
  </tr>
</table>

<p>This data will need to placed in the directory specified by the QSTrader settings file if you wish to replicate the results.</p>

<h2>Python QSTrader Implementation</h2>

<p><em><strong>Note that the full listings of each of these Python files can be found at the end of the article.</strong></em></p>

<p><em>Note also that this strategy contains an <strong>implicit lookahead bias</strong> and so its performance will be grossly exaggerated compared to a real implementation. The lookahead bias occurs due to the use of calculating the hedging ratio across the same sample of data as the trading strategy is simulated on. In a real implementation two separate sets of data will be needed in order to verify that any structural relationship persists out-of-sample.</em></p>

<p>The implementation of the strategy is similar to other QSTrader strategies. It involves the creation of a subclass of <code>AbstractStrategy</code> in the <code>coint_bollinger_strategy.py</code> file. This class is then used by the <code>coint_bollinger_backtest.py</code> file to actually simulate the backtest.</p>

<p><code>coint_bollinger_strategy.py</code> will be described first. NumPy is imported, as are the necessary QSTrader libraries for handling signals and strategies. <code>PriceParser</code> is brought in to adjust the internal handling of QSTrader's price storage mechanism to avoid floating-point round-off error.</p>

<p>The <a href="https://docs.python.org/3/library/collections.html#collections.deque">deque</a>–double-ended queue–class is also imported and used to store a rolling window of closing price bars, necessary for the moving average and standard deviation lookback calculations. More on this below.</p>

<pre>
<code class="language-python"># coint_bollinger_strategy.py

from __future__ import print_function

from collections import deque
from math import floor

import numpy as np

from qstrader.price_parser import PriceParser
from qstrader.event import (SignalEvent, EventType)
from qstrader.strategy.base import AbstractStrategy</code>
</pre>

<p>The next step is to define the <code>CointegrationBollingerBandsStrategy</code> subclass of <code>AbstractStrategy</code>, which carries out the signals generation. As with all strategies it requires a list of <code>tickers</code> that it acts upon as well as a handle to the <code>events_queue</code> upon which to place the <code>SignalEvent</code> objects.</p>

<p>This subclass requires additional parameters. <code>lookback</code> is the integer number of bars over which to perform the rolling moving average and standard deviation calculations. <code>weights</code> is the set of <em>fixed</em> hedging ratios, or primary Johansen test eigenvector components, to use as the "unit" of a portfolio of cointegrating assets.</p>

<p><code>entry_z</code> describes the multiple of z-score entry threshold (i.e. number of standard deviations) upon which to open a trade. <code>exit_z</code> is the corresponding number of standard deviations upon which to exit the trade. <code>base_quantity</code> is the integer number of "units" of the portfolio to trade.</p>

<p>In addition the class also keeps track of the latest prices of all tickers in a separate array in <code>self.latest_prices</code>. It also contains a double-ended queue consisting of the last <code>lookback</code> values of the market value of a "unit" of the portfolio in <code>self.port_mkt_value</code>. A <code>self.invested</code> flag allows the strategy itself to keep track of whether it is "in the market" or not:</p>

<pre>
<code class="language-python">class CointegrationBollingerBandsStrategy(AbstractStrategy):
    """
    Requires:
    tickers - The list of ticker symbols
    events_queue - A handle to the system events queue
    lookback - Lookback period for moving avg and moving std
    weights - The weight vector describing 
        a "unit" of the portfolio
    entry_z - The z-score trade entry threshold
    exit_z - The z-score trade exit threshold
    base_quantity - Number of "units" of the portfolio 
        to be traded
    """
    def __init__(
        self, tickers, events_queue, 
        lookback, weights, entry_z, exit_z,
        base_quantity
    ):
        self.tickers = tickers
        self.events_queue = events_queue      
        self.lookback = lookback
        self.weights = weights
        self.entry_z = entry_z
        self.exit_z = exit_z
        self.qty = base_quantity
        self.time = None
        self.latest_prices = np.full(len(self.tickers), -1.0)
        self.port_mkt_val = deque(maxlen=self.lookback)
        self.invested = None
        self.bars_elapsed = 0</code>
</pre>

<p>The following <code>_set_correct_time_and_price</code> method is similar to that found in the <a href="https://www.quantstart.com/articles/kalman-filter-based-pairs-trading-strategy-in-qstrader">QSTrader Kalman Filter article</a>. The goal of this method is to make sure that the <code>self.latest_prices</code> array is populated with the latest market values of each ticker. The strategy will only execute if this array contains a full set of prices, all containing the same time-stamp (i.e. representing the same timeframe over a bar).</p>

<p>The previous version of this method was fixed for an array of two prices but the code below works for any number of tickers, which is necessary for cointegrating portfolios that might contain three or more assets:</p>

<pre>
<code class="language-python">def _set_correct_time_and_price(self, event):
    """
    Sets the correct price and event time for prices
    that arrive out of order in the events queue.
    """
    # Set the first instance of time
    if self.time is None:
        self.time = event.time
    
    # Set the correct latest prices depending upon 
    # order of arrival of market bar event
    price = event.adj_close_price/PriceParser.PRICE_MULTIPLIER
    if event.time == self.time:
        for i in range(0, len(self.tickers)):
            if event.ticker == self.tickers[i]:
                self.latest_prices[i] = price
    else:
        self.time = event.time
        self.bars_elapsed += 1
        self.latest_prices = np.full(len(self.tickers), -1.0)
        for i in range(0, len(self.tickers)):
            if event.ticker == self.tickers[i]:
                self.latest_prices[i] = price</code>
</pre>

<p><code>go_long_units</code> is a helper method that longs the appropriate quantity of portfolio "units" by purchasing their individual components separately in the correct quantities. It achieves this by shorting any component that has a negative value in the <code>self.weights</code> array and by longing any component that has a positive value. Note that it multiplies this by the <code>self.qty</code> value, which is the base number of units to transact for a portfolio "unit":</p>

<pre>
<code class="language-python">def go_long_units(self):
    """
    Go long the appropriate number of "units" of the 
    portfolio to open a new position or to close out 
    a short position.
    """
    for i, ticker in enumerate(self.tickers):
        if self.weights[i] < 0.0:
            self.events_queue.put(SignalEvent(
                ticker, "SLD", 
                int(floor(-1.0*self.qty*self.weights[i])))
            )
        else:
            self.events_queue.put(SignalEvent(
                ticker, "BOT", 
                int(floor(self.qty*self.weights[i])))</code>
</pre>

<p><code>go_short_units</code> is almost identical to the above method except that it swaps the long/short commands, so that the positions can be closed or shorted:</p>

<pre>
<code class="language-python">def go_short_units(self):
    """
    Go short the appropriate number of "units" of the 
    portfolio to open a new position or to close out 
    a long position.
    """
    for i, ticker in enumerate(self.tickers):
        if self.weights[i] < 0.0:
            self.events_queue.put(SignalEvent(
                ticker, "BOT", 
                int(floor(-1.0*self.qty*self.weights[i])))
            )
        else:
            self.events_queue.put(SignalEvent(
                ticker, "SLD", 
                int(floor(self.qty*self.weights[i])))
            )</code>
</pre>

<p><code>zscore_trade</code> takes the latest calculated z-score of the portfolio market price and uses this to long, short or close a trade. The logic below encapsulates the "Bollinger Bands" aspect of the strategy.</p>

<p>If the z-score is less than the negative of the entry threshold, a long position is created. If the z-score is greater than the positive of the entry threshold, a short position is created. Correspondingly, if the strategy is already in the market and the z-score exceeds the negative of the exit threshold, any long position is closed. If the strategy is already in the market and the z-score is less than the exit threshold, a short position is closed:</p> 

<pre>
<code class="language-python">def zscore_trade(self, zscore, event):
    """
    Determine whether to trade if the entry or exit zscore
    threshold has been exceeded.
    """
    # If we're not in the market...
    if self.invested is None:
        if zscore < -self.entry_z:  
            # Long Entry
            print("LONG: %s" % event.time)
            self.go_long_units()
            self.invested = "long"
        elif zscore > self.entry_z:  
            # Short Entry
            print("SHORT: %s" % event.time)
            self.go_short_units()
            self.invested = "short"
    # If we are in the market...
    if self.invested is not None:
        if self.invested == "long" and zscore >= -self.exit_z:
            print("CLOSING LONG: %s" % event.time)
            self.go_short_units()
            self.invested = None
        elif self.invested == "short" and zscore <= self.exit_z:
            print("CLOSING SHORT: %s" % event.time)
            self.go_long_units()
            self.invested = None</code>
</pre>

<p>Finally, the <code>calculate_signals</code> method makes sure the <code>self.latest_prices</code> array is fully up to date and only trades if all the latest prices exist. If these prices do exist, the <code>self.port_mkt_val</code> deque is updated to contain the latest "market value" of a unit portfolio. This is simply the dot product of the latest prices of each constituent and their weight vector.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Standard_score">z-score</a> of the latest portfolio unit market value is then calculated by subtracting the rolling mean and dividing by the rolling standard deviation. This z-score is then sent to the above method <code>zscore_trade</code> to generate the trading signals:</p>

<pre>
<code class="language-python">def calculate_signals(self, event):
    """
    Calculate the signals for the strategy.
    """
    if event.type == EventType.BAR:
        self._set_correct_time_and_price(event)

        # Only trade if we have all prices
        if all(self.latest_prices > -1.0):
            # Calculate portfolio market value via dot product
            # of ETF prices with portfolio weights
            self.port_mkt_val.append(
                np.dot(self.latest_prices, self.weights)
            )
            # If there is enough data to form a full lookback
            # window, then calculate zscore and carry out
            # respective trades if thresholds are exceeded
            if self.bars_elapsed > self.lookback:
                zscore = (
                    self.port_mkt_val[-1] - np.mean(self.port_mkt_val)
                ) / np.std(self.port_mkt_val)
                self.zscore_trade(zscore, event)</code>
</pre>

<p>The remaining file is <code>coint_bollinger_backtest.py</code>, which wraps the strategy class in backtesting logic. It is extremely similar to all other QSTrader backtest files discussed on the site. While the full listing is given below at the end of the article, the snippet directly below references the important aspect where the <code>CointegrationBollingerBandsStrategy</code> is created.</p>

<p>The <code>weights</code> array is hardcoded from the values obtained from the R CADF procedure above, while the <code>lookback</code> period is (arbitrarily) set to 15 values. The entry and exit z-score thresholds are set of 1.5 and 0.5 standard deviations, respectively. Since the account equity is set at 500,000 USD the <code>base_quantity</code> of shares is set to 10,000.</p>

<p><em>These values can all be tested and optimised, e.g. through a grid-search procedure, if desired.</em></p>

<pre>
<code class="language-python"># coint_bollinger_strategy.py

..
..


# Use the Cointegration Bollinger Bands trading strategy
weights = np.array([1.0, -1.213])
lookback = 15
entry_z = 1.5
exit_z = 0.5
base_quantity = 10000
strategy = CointegrationBollingerBandsStrategy(
    tickers, events_queue, 
    lookback, weights, 
    entry_z, exit_z, base_quantity
)
strategy = Strategies(strategy, DisplayStrategy())

..
..</code>
</pre>

<p>To run the backtest a working installation of QSTrader is needed and these two files described above need to be placed in the same directory. Assuming the availability of the ARNC and UNG data, the backtest will execute upon typing the following command into the terminal:</p>

<pre>
<code class="language-bash">$ python coint_bollinger_backtest.py --tickers=ARNC,UNG</code>
</pre>

<p>You will receive the following (truncated) output:</p>

<pre>
<code class="language-none">..
..
Backtest complete.
Sharpe Ratio: 1.22071888063
Max Drawdown: 0.0701967400339
Max Drawdown Pct: 0.0701967400339</code>
</pre>

<h2>Strategy Results</h2>

<h3>Transaction Costs</h3>

<p>The strategy results presented here are given <em>net</em> of transaction costs. The costs are simulated using <a href="https://www.interactivebrokers.co.uk/en/index.php?f=1590&p=stocks1">Interactive Brokers US equities fixed pricing for shares in North America</a>. They do not take into account commission differences for ETFs, but they are reasonably representative of what could be achieved in a real trading strategy.</p>

<h3>Tearsheet</h3>

<p style="text-align:center;">
  <a href="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-tearsheet.png">
    <img width="100%" src="https://s3.amazonaws.com/quantstartmedia/images/qs-qstrader-coint-aluminium-tearsheet.png">
  </a>
</p>

<p><em>Click the image for a larger view.</em></p>

<p><em>Once again recall that this strategy contains an <strong>implicit lookahead bias</strong> due to the fact that the CADF procedure was carried out over the same sample of data as the trading strategy.</em></p>

<p>With that in mind, the strategy posts a Sharpe Ratio of 1.22, with a maximum daily drawdown of 7.02%. The majority of the strategy gains occur in a single month within January 2015, after which the strategy performs poorly. It remains in drawdown throughout 2016. This is not surprising since no statistically significant cointegrating relationship was found between ARNC and UNG across the period studied, at least using the ADF test procedure.</p>

<p>In order to improve this strategy a more refined view of the economics of the aluminum smelting process could be taken. For instance, while there is a clear need for electricity to carry out the electrolysis process, this power can be derived from many sources, including hydroelectric, coal, nuclear and, likely in the future, wind and solar. A more comprehensive portfolio including the price of aluminum, large aluminum producers, and ETFs representing varying energy sources might be considered.</p>

<h2>References</h2>

<ul>
  <li><a name="ref-chan2013" href="http://amzn.to/1Olr09O">[1] Chan, E. P. (2013) <em>Algorithmic Trading: Winning Strategies and their Rationale</em>, Wiley</a></li>
  <li><a name="ref-fawcett2012" href="https://www.quantopian.com/posts/ernie-chans-gold-vs-gold-miners-stat-arb">[2] Fawcett, J. (2012) <em>Ernie Chan's "Gold vs. gold-miners" stat arb</em>, https://www.quantopian.com/posts/ernie-chans-gold-vs-gold-miners-stat-arb</a></li>
  <li><a name="ref-reiakvam2011" href="http://www.diva-portal.org/smash/get/diva2:480284/FULLTEXT01.pdf">[3] Reiakvam, O.H., Thyness, S.B. (2011) "Pairs Trading in the Aluminum Market: A Cointegration Approach", Masters Thesis, <em>Norwegian University of Science and Technology</em></a></li>
</ul>

<h2>Full Code</h2>

<pre>
<code class="language-r"># coint_cadf.R

library("quantmod")
library("tseries")

## Obtain ARNC and UNG
getSymbols("ARNC", from="2014-11-11", to="2017-01-01")
getSymbols("UNG", from="2014-11-11", to="2017-01-01")

## Utilise the backwards-adjusted closing prices
aAdj = unclass(ARNC$ARNC.Adjusted)
bAdj = unclass(UNG$UNG.Adjusted)

## Plot the ETF backward-adjusted closing prices
plot(aAdj, type="l", xlim=c(0, length(aAdj)), ylim=c(0.0, 45.0), xlab="November 11th 2014 to January 1st 2017", ylab="Backward-Adjusted Prices in USD", col="blue")
par(new=T)
plot(bAdj, type="l", xlim=c(0, length(bAdj)), ylim=c(0.0, 45.0), axes=F, xlab="", ylab="", col="red")
par(new=F)

## Plot a scatter graph of the ETF adjusted prices
plot(aAdj, bAdj, xlab="ARNC Backward-Adjusted Prices", ylab="UNG Backward-Adjusted Prices")

## Carry out linear regression on the two price series
comb = lm(aAdj~bAdj)

## Now we perform the ADF test on the residuals,
## or "spread" on the model, using a single lag order
adf.test(comb$residuals, k=1)</code>
</pre>

<pre>
<code class="language-python"># coint_bollinger_strategy.py

from __future__ import print_function

from collections import deque
from math import floor

import numpy as np

from qstrader.price_parser import PriceParser
from qstrader.event import (SignalEvent, EventType)
from qstrader.strategy.base import AbstractStrategy


class CointegrationBollingerBandsStrategy(AbstractStrategy):
    """
    Requires:
    tickers - The list of ticker symbols
    events_queue - A handle to the system events queue
    lookback - Lookback period for moving avg and moving std
    weights - The weight vector describing 
        a "unit" of the portfolio
    entry_z - The z-score trade entry threshold
    exit_z - The z-score trade exit threshold
    base_quantity - Number of "units" of the portfolio 
        to be traded
    """
    def __init__(
        self, tickers, events_queue, 
        lookback, weights, entry_z, exit_z,
        base_quantity
    ):
        self.tickers = tickers
        self.events_queue = events_queue      
        self.lookback = lookback
        self.weights = weights
        self.entry_z = entry_z
        self.exit_z = exit_z
        self.qty = base_quantity
        self.time = None
        self.latest_prices = np.full(len(self.tickers), -1.0)
        self.port_mkt_val = deque(maxlen=self.lookback)
        self.invested = None
        self.bars_elapsed = 0

    def _set_correct_time_and_price(self, event):
        """
        Sets the correct price and event time for prices
        that arrive out of order in the events queue.
        """
        # Set the first instance of time
        if self.time is None:
            self.time = event.time
        
        # Set the correct latest prices depending upon 
        # order of arrival of market bar event
        price = event.adj_close_price/PriceParser.PRICE_MULTIPLIER
        if event.time == self.time:
            for i in range(0, len(self.tickers)):
                if event.ticker == self.tickers[i]:
                    self.latest_prices[i] = price
        else:
            self.time = event.time
            self.bars_elapsed += 1
            self.latest_prices = np.full(len(self.tickers), -1.0)
            for i in range(0, len(self.tickers)):
                if event.ticker == self.tickers[i]:
                    self.latest_prices[i] = price

    def go_long_units(self):
        """
        Go long the appropriate number of "units" of the 
        portfolio to open a new position or to close out 
        a short position.
        """
        for i, ticker in enumerate(self.tickers):
            if self.weights[i] < 0.0:
                self.events_queue.put(SignalEvent(
                    ticker, "SLD", 
                    int(floor(-1.0*self.qty*self.weights[i])))
                )
            else:
                self.events_queue.put(SignalEvent(
                    ticker, "BOT", 
                    int(floor(self.qty*self.weights[i])))
                )

    def go_short_units(self):
        """
        Go short the appropriate number of "units" of the 
        portfolio to open a new position or to close out 
        a long position.
        """
        for i, ticker in enumerate(self.tickers):
            if self.weights[i] < 0.0:
                self.events_queue.put(SignalEvent(
                    ticker, "BOT", 
                    int(floor(-1.0*self.qty*self.weights[i])))
                )
            else:
                self.events_queue.put(SignalEvent(
                    ticker, "SLD", 
                    int(floor(self.qty*self.weights[i])))
                )

    def zscore_trade(self, zscore, event):
        """
        Determine whether to trade if the entry or exit zscore
        threshold has been exceeded.
        """
        # If we're not in the market...
        if self.invested is None:
            if zscore < -self.entry_z:  
                # Long Entry
                print("LONG: %s" % event.time)
                self.go_long_units()
                self.invested = "long"
            elif zscore > self.entry_z:  
                # Short Entry
                print("SHORT: %s" % event.time)
                self.go_short_units()
                self.invested = "short"
        # If we are in the market...
        if self.invested is not None:
            if self.invested == "long" and zscore >= -self.exit_z:
                print("CLOSING LONG: %s" % event.time)
                self.go_short_units()
                self.invested = None
            elif self.invested == "short" and zscore <= self.exit_z:
                print("CLOSING SHORT: %s" % event.time)
                self.go_long_units()
                self.invested = None

    def calculate_signals(self, event):
        """
        Calculate the signals for the strategy.
        """
        if event.type == EventType.BAR:
            self._set_correct_time_and_price(event)

            # Only trade if we have all prices
            if all(self.latest_prices > -1.0):
                # Calculate portfolio market value via dot product
                # of ETF prices with portfolio weights
                self.port_mkt_val.append(
                    np.dot(self.latest_prices, self.weights)
                )
                # If there is enough data to form a full lookback
                # window, then calculate zscore and carry out
                # respective trades if thresholds are exceeded
                if self.bars_elapsed > self.lookback:
                    zscore = (
                        self.port_mkt_val[-1] - np.mean(self.port_mkt_val)
                    ) / np.std(self.port_mkt_val)
                    self.zscore_trade(zscore, event)</code>
</pre>

<pre>
<code class="language-python"># coint_bollinger_backtest.py

import datetime

import click
import numpy as np

from qstrader import settings
from qstrader.compat import queue
from qstrader.price_parser import PriceParser
from qstrader.price_handler.yahoo_daily_csv_bar import YahooDailyCsvBarPriceHandler
from qstrader.strategy import Strategies, DisplayStrategy
from qstrader.position_sizer.naive import NaivePositionSizer
from qstrader.risk_manager.example import ExampleRiskManager
from qstrader.portfolio_handler import PortfolioHandler
from qstrader.compliance.example import ExampleCompliance
from qstrader.execution_handler.ib_simulated import IBSimulatedExecutionHandler
from qstrader.statistics.tearsheet import TearsheetStatistics
from qstrader.trading_session.backtest import Backtest

from coint_bollinger_strategy import CointegrationBollingerBandsStrategy


def run(config, testing, tickers, filename):

    # Set up variables needed for backtest
    events_queue = queue.Queue()
    csv_dir = config.CSV_DATA_DIR
    initial_equity = PriceParser.parse(500000.00)

    # Use Yahoo Daily Price Handler
    start_date = datetime.datetime(2015, 1, 1)
    end_date = datetime.datetime(2016, 9, 1)
    price_handler = YahooDailyCsvBarPriceHandler(
        csv_dir, events_queue, tickers,
        start_date=start_date, end_date=end_date
    )

    # Use the Cointegration Bollinger Bands trading strategy
    weights = np.array([1.0, -1.213])
    lookback = 15
    entry_z = 1.5
    exit_z = 0.5
    base_quantity = 10000
    strategy = CointegrationBollingerBandsStrategy(
        tickers, events_queue, 
        lookback, weights, 
        entry_z, exit_z, base_quantity
    )
    strategy = Strategies(strategy, DisplayStrategy())

    # Use the Naive Position Sizer 
    # where suggested quantities are followed
    position_sizer = NaivePositionSizer()

    # Use an example Risk Manager
    risk_manager = ExampleRiskManager()

    # Use the default Portfolio Handler
    portfolio_handler = PortfolioHandler(
        initial_equity, events_queue, price_handler,
        position_sizer, risk_manager
    )

    # Use the ExampleCompliance component
    compliance = ExampleCompliance(config)

    # Use a simulated IB Execution Handler
    execution_handler = IBSimulatedExecutionHandler(
        events_queue, price_handler, compliance
    )

    # Use the Tearsheet Statistics
    title = ["aluminum Smelting Strategy - ARNC/UNG"]
    statistics = TearsheetStatistics(
        config, portfolio_handler, title
    )

    # Set up the backtest
    backtest = Backtest(
        price_handler, strategy,
        portfolio_handler, execution_handler,
        position_sizer, risk_manager,
        statistics, initial_equity
    )
    results = backtest.simulate_trading(testing=testing)
    statistics.save(filename)
    return results


@click.command()
@click.option('--config', default=settings.DEFAULT_CONFIG_FILENAME, help='Config filename')
@click.option('--testing/--no-testing', default=False, help='Enable testing mode')
@click.option('--tickers', default='SPY', help='Tickers (use comma)')
@click.option('--filename', default='', help='Pickle (.pkl) statistics filename')
def main(config, testing, tickers, filename):
    tickers = tickers.split(",")
    config = settings.from_file(config, testing)
    run(config, testing, tickers, filename)


if __name__ == "__main__":
    main()</code>
</pre>
        
        
        <script async data-uid="6296c27f4b" src="https://weathered-brook-5281.ck.page/6296c27f4b/index.js"></script>
      </section>
    </div>
    <div class="col-md-4 book-card order-md-1">
      
<div class="sidebar-advert-container">
  <a href="/qsalpha/?ref=art">
    <img class="card-img-top" src="/static/images/qsalpha-sidebar-advert-small.png" alt="QSAlpha">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/qsalpha/?ref=art">QSAlpha</a></h3>
      <p class="card-text medium-text mb-3">Join the QSAlpha research platform that helps fill your strategy research pipeline, diversifies your portfolio and improves your risk-adjusted returns for increased profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/qsalpha/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/quantcademy/?ref=art">
    <img class="card-img-top" src="/static/images/quantcademy-sidebar-advert-small.png" alt="Quantcademy">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/quantcademy/?ref=art">The Quantcademy</a></h3>
      <p class="card-text medium-text mb-3">Join the Quantcademy membership portal that caters to the rapidly-growing retail quant trader community and learn how to increase your strategy profitability.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/quantcademy/?ref=art">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/successful-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/sat-sidebar-advert-small.png" alt="Successful Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to find new trading strategy ideas and objectively assess them for your portfolio using a Python-based backtesting engine.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/successful-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>

  <a href="/advanced-algorithmic-trading-ebook/">
    <img class="card-img-top" src="/static/images/aat-sidebar-advert-small.png" alt="Advanced Algorithmic Trading">
  </a>
  <div class="card mb-4 box-shadow">
    <div class="card-body text-center">
      <h3 class="mb-3"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></h3>
      <p class="card-text medium-text mb-3">How to implement advanced trading strategies using time series analysis, machine learning and Bayesian statistics with R and Python.</p>
      <div class="d-flex justify-content-center align-items-center">
        <div class="btn-group">
          <a class="btn btn-padded btn-outline-primary btn-lg-cta" href="/advanced-algorithmic-trading-ebook/">Find Out More</a>
        </div>
      </div>
    </div>
  </div>
</div>
    </div>
  </div>
</section>

    

<footer>
  <div class="container container-full">
    <section class="mt-1.5 mb-1">
      <div class="row">
        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">QuantStart</li>
            <li class="footer-list-link"><a class="link-fade" href="/about/">About</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/articles/">Articles</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/sitemap/">Sitemap</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Products</li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qsalpha/">QSAlpha</a></li>
            
            
            <li class="footer-list-link"><a class="link-fade" href="/quantcademy/">Quantcademy</a></li>
            
            <li class="footer-list-link"><a class="link-fade" href="/qstrader/">QSTrader</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/successful-algorithmic-trading-ebook/">Successful Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/advanced-algorithmic-trading-ebook/">Advanced Algorithmic Trading</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/cpp-for-quantitative-finance-ebook/">C++ For Quantitative Finance</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Legal</li>
            <li class="footer-list-link"><a class="link-fade" href="/privacy-policy/">Privacy Policy</a></li>
            <li class="footer-list-link"><a class="link-fade" href="/terms-and-conditions/">Terms &amp; Conditions</a></li>
          </ul>
        </div>

        <div class="col-12 col-sm-12 col-md-6 col-xl-3 mb-1.5">
          <ul class="footer-list">
            <li class="footer-list-title">Social</li>
            <li class="footer-list-link"><a class="link-fade" href="https://twitter.com/quantstart">Twitter</a></li>
            <li class="footer-list-link"><a class="link-fade" href="https://www.youtube.com/channel/UCmVnnZ6Y2TrJtY1eQJN6kWA">YouTube</a></li>
          </ul>
        </div>
      </div>
    </section>

    <div class="row mb-1.5 mt-5">
      <div class="col-12 col-md-9 col-lg-8 col-xl-6">
        <div class="footer-copyright">
          <p>©2012-2023 QuarkGluon Ltd. All rights reserved.</p>
        </div>
      </div>
    </div>
  </div>
</footer>

    
<script src="/static/js/jquery-3.2.1.min.js"></script>
<script src="/static/js/prism.js.min"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/nav.js"></script>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5383959-5']);
  _gaq.push(['_trackPageview']);

  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="/static/js/highcharts/highcharts.js"></script>
<script type="text/javascript">
  num_colours = 10;
</script>
<script src="/static/js/statistics.js"></script>


  </body>
</html>
